* Crafting interpreters
** 1부 | 환영한다!
*** 1장 들어가기
**** 1.1 왜 이런 걸 배우는가?
***** 1.1.1 미니 언어는 곳곳에 있다
***** 1.1.2 언어는 훌륭한 연습이다
***** 1.1.3 한 가지 더
**** 1.2 이 책의 구성
***** 1.2.1 코드
***** 1.2.2 스니펫
***** 1.2.3 어사이드
***** 1.2.4 연습 문제
***** 1.2.5 디자인 노트
**** 1.3 첫 번째 인터프리터
**** 1.4 두 번째 인터프리터
**** 연습 문제
**** 디자인 노트 | 언어 이름 짓기
*** 2장 인터프리터 원정대
**** 2.1 언어의 구성 요소
***** 2.1.1 스캐닝
- 스캐너(scanner 또는 렉서)는 문자의 선형 스트림을 받아 *'단어'에 더 가까운 연속적인 청크* 들로 묶는다
  - 프로그래밍 언어에서는 이런 단어들을 **토큰** 이라고 한다
  - 스캐너는 공백문자, 주석과 같은 토큰은 버리고 일련의 의미 있는 토큰들로 정리한다
***** 2.1.2 파싱
- 파싱은 작은 부품들을 모아 더 큰 표현식과 문장을 구성하는 능력이다
- 파서는 플랫한 일련의 토큰을 받아 *문법 특유의 중첩된 성질을 반영하는 트리 구조* 로 만든다
  - 이 트리는 소스 언어의 원시 구문 구조에 얼마나 가까운지에 따라 **파스 트리** 또는 **추상 구문 트리** 라고 불린다
***** 2.1.3 정적 분석
- 바인딩(또는 레졸루션)은 식별자마다 이름이 정의된 곳을 찾아 이 둘을 연결 짓는 행위다
- 스코프는 어떤 이름으로 어떤 선언을 참조할 수 있는 소스 코드의 영역이다
- 분석(e.g. 바인딩)을 통해 알아낸 모든 시맨틱 정보 보관방법
  - 구문 트리 자체의 (노드의 추가 필드) 애트리뷰트에 저장한다
  - 조회 테이블에 데이터를 저장한다
  - 시맨틱이 직접적으로 표현된 새로운 자료구조로 트리를 변환한다
- 지금까지 일어난 일 (스캐닝, 파싱, 정적분석)은 **프런트엔드** 에 해당한다
- 이 다음으로는 **미들엔드** 에 해당한다
***** 2.1.4 중간 표현
- 컴파일러는 각 단계별 작업이 다음 단계를 구현하기 쉽게 만드는 방향으로 사용자 코드를 나타내는 일종의 데이터를 구성하는 파이프라인으로 볼 수 있다
  - 프론트엔드는 프로그램이 작성된 소스언어에 연관되어 있고
  - 백엔드는 프로그램이 최종 실행될 타깃 아키텍처와 연관되어 있다
- 중간표현(IR, Intermediate Representation) 은 소스/타깃 포맷 어느 쪽에도 엮이지 않는다
- IR 을 공유하면 작업이 획기적으로 줄어든다
***** 2.1.5 최적화
- 사용자 프로그램이 의미하는 바(시맨틱)를 파악하고 나면, 더 효율적으로 구현한 다른 프로그램으로 자유로이 갈아 끼울 수 있다
  - 즉, **최적화** 할 수 있다
  - 예시: 상수 폴딩(constant folding)
    - 항상 같은 값으로 평가되는 표현식을 컴파일 타임에 미리 평가해서 표현식 코드를 그 결괏값으로 대체하는 기법
***** 2.1.6 코드 생성
- 코드 생성(코드젠)은 머신이 실제로 작동시킬 수 있는 형태로 바꾸는 것이다
- 실제 CPU 명령어 vs 가상 CPU 명령어
  - 실제 기계어를 생성하면 OS가 칩에 직접 로드할 수 있는 실행 파일이 나온다
***** 2.1.7 가상 머신
- 옵션
  - 1. 바이트코드를 해당 머신의 네이티브 코드로 바꿔주는 미니 컴파일러를 각 타깃 아키텍처마다 만드는 것이다
  - 2. 런타임에 가상의 아키텍처를 지원하는 가상의 칩을 에뮬레이터하는 프로그램, **가상 머신** 을 만든다
***** 2.1.8 런타임
- 프로그램 실행 중에 언어가 기본 제공하는 몇 가지 서비스가 필요하다 (**런타임**)
  - e.g. 가비지 수집기, 각 객체의 타입 추적하기
  - 구현 방법
    - 컴파일 언어에서는 결과 실행 파일에 직접 삽입된다
    - 인터프리터나 VM 내부에서 실행되는 언어는 이 내부에 상주한다
**** 2.2 지름길과 대체 경로
***** 2.2.1 싱글 패스 컴파일러
- 싱글 패스 컴파일러: 구문트리나 IR 을 할당하지 않고 파서에서 출력코드를 직접 생성하는 단순한 컴파일러
  - 프로그램에 관한 글로벌 정보를 보관할 중간 자료 구조도 없고
  - 이전에 파싱한 코드를 다시 방문하지도 않는다
***** 2.2.2 트리 탐색 인터프리터
- 코드를 AST 로 파싱한 후 바로 실행을 시작한다
- 프로그램을 실행하기 위해 인터프리터는 구문 트리를 한 번에 하나의 분기와 리프씩 순회하면서 각 노드를 평가한다
***** 2.2.3 트랜스파일러
***** 2.2.4 JIT 컴파일
- JIT 은 프로그램이 로드되면 그 프로그램이 실행될 컴퓨터에서 지원되는 아키텍처의 네이티브 코드로 컴파일된다
- JIT 는 또한 생성된 코드에 프로파일링 훅을 삽입해서 어느 부분이 성능에 가장 큰 영향을 미치는지, 어떤 종류의 데이터가 이 부분을 통과해서 흘러가는지 조사한다
- 점점 시간이 흐르면서 이런 핫스팟에 더 최적화된 옵션을 적용하여 자동으로 재컴파일을 수행한다
**** 2.3 컴파일러와 인터프리터
**** 2.4 여행을 떠나자!
**** 연습 문제
*** 3장 록스 언어
**** 3.1 안녕, 록스
**** 3.2 하이레벨 언어
***** 3.2.1 동적 타이핑
- 동적 타입 언어
  - 변수에 어떤 타입의 값이라도 담을 수 있다
  - 하나의 변수는 임의의 시간에 타입이 다른 값을 보관할 수 있다
  - 잘못된 타입의 값에 연산을 수행하면 런타임 에러가 감지되어 리포트된다
***** 3.2.2 자동 메모리 관리
- 참조 횟수 계산 방식과 가비지 컬렉션 방법이 있다
**** 3.3 데이터 타입
**** 3.4 표현식
***** 3.4.1 산술
***** 3.4.2 비교와 동등성
***** 3.4.3 논리 연산자
***** 3.4.4 우선순위와 그룹핑
**** 3.5 문장
**** 3.6 변수
**** 3.7 제어 흐름
**** 3.8 함수
***** 3.8.1 클로저
- `inner()`는 자신이 사용하는 모든 주변 변수의 참조를 외부 함수가 리턴된 이후에도 계속 바라볼 수 있게 어딘가에 보관해야 한다. 이 일을 하는 함수를 **클로저** 라고 한다 
**** 3.9 클래스
***** 3.9.1 객체 지향 언어를 추구해야 할 이유가 있을까?
***** 3.9.2 록스는 왜 객체 지향 언어로 만들었나?
***** 3.9.3 클래스냐 프로토타입이냐
***** 3.9.4 록스의 클래스
***** 3.9.5 인스턴스화 및 초기화
***** 3.9.6 상속
**** 3.10 표준 라이브러리
**** 연습 문제
**** 디자인 노트 | 표현식과 문장
** 2부 | 트리 탐색 인터프리터
*** 4장 스캐닝
- 컴파일러 또는 인터프리터의 첫 번째 단계는 스캐닝이다
- 스캐너는 원시 소스 코드를 일련의 문자로 입력받아 **토큰** 이라는 여러 청크들로 묶는다
- 이들 청크는 언어의 문법을 구성하는 유의미한 *단어(word)* 와 *문장부호(punctuation)* 이다
**** 4.1 인터프리터 프레임워크
***** 4.1.1 에러 처리
**** 4.2 렉심과 토큰
- 렉시컬 분석: 문자 리스트를 끝까지 쭉 스캐닝해서 *뭔가를 나타내는* 가장 작은 시퀀스로 묶는다
  - 각 문자 덩어리(원시 서브 문자열)를 **렉심(어휘소)** 라고 한다
  - 렉심을 가져와 다른 데이터와 함께 묶으면 토큰이 된다
***** 4.2.1 토큰 타입
- 파서는 토큰이 어떤 특성의 렉심을 갖고 있는지 알아야 한다. (e.g. 식별자, 예약어, 키워드 etc)
***** 4.2.2 리터럴 값
***** 4.2.3 위치 정보
**** 4.3 정규 언어와 표현식
- 어떤 언어에서 문자를 렉심으로 묶는 규칙을 **렉시컬 문법** 이라고 한다
**** 4.4 스캐너 클래스
**** 4.5 렉심 식별하기
***** 4.5.1 렉시컬 에러
***** 4.5.2 연산자
**** 4.6 길이가 긴 렉심
***** 4.6.1 문자열 리터럴
***** 4.6.2 숫자 리터럴
**** 4.7 예약어와 식별자
- 최대한 잘라먹기(maximal munch)
  - 스캐너가 읽어 들인 코드 청크가 두 렉시컬 문법이 모두 매치될 경우 '가장 많은 문자가 매치된 쪽이 승리'한다는 규칙
**** 연습 문제
**** 디자인 노트 | 암묵적 세미콜론
*** 5장 코드 표현
- 원시 소스 코드를 문자열로 가져와 더 하이레벨 표현인 일련의 토큰으로 변환했다
- 파서가 만들 다음 코드 표현은 인터프리터가 소비(평가)하기 쉬워야한다
  - 우선순위는 트리형태로 시각화하면 알기 쉽다
  - 리프노드는 숫자, 내부 노드는 각 피연산자로 분기되는 연산자다
  - 산술 노드를 평가하려면 서브트리의 숫자 값을 알아야 하므로 먼저 값을 평가해야 한다. 즉 리프(숫자)에서 시작해 루트로 올라가는 후위 순회를 한다
**** 5.1 컨텍스트 자유 문법
- 정규언어: 렉시컬 문법을 정의하기 위해 사용한 형식
  - 문자를 토큰으로 묶는 규칙
- 플랬한 토큰 시퀀스만 내보내는 록스 스캐너에는 정규 언어로도 충분하지만, *임의로 깊게 중첩 가능한 표현식* 을 처리할 만큼 강력하진 못하다
- 형식문법은 알파벳이라는 원자적 조각들의 집합을 받아 *문법* 에 속하는 문자열 집합을 정의한다
- 알파벳
  - 렉시컬 문법: 문자
  - 구문(syntactic) 문법: 토큰
- 문자열
  - 렉시컬 문법: 렉심 또는 토큰
  - 구문 문법: 표현식
- 구현
  - 렉시컬 문법: 스캐너
  - 구문 문법: 파서
- 형식 문법이 하는 일은 어떤 문자열이 올바른지 가려내는 것
  - `tasty breakfast for are eggs` 는 올바른 문장이 아니다
***** 5.1.1 문법 규칙
- 올바른 문자열이 담긴 문법을 어떻게 기록할까?
  - 유한한 규칙 집합을 만든다
- 규칙을 이용해 문법에 맞는 문자열을 생성한다
  - 이렇게 만든 문자열은 문법의 규칙에서 파생된 것이므로 **파생어(derivation)** 이라 한다
  - 게임의 각 단계에서 규칙을 선택하고 그 규칙이 지시하는 바를 따른다
- 규칙은 문법에 맞는 문자열을 생성하므로 **프로덕션(production)** 이라 한다
- 컨텍스트 자유 문법의 각 프로덕션에는 **헤드** 와 생성한 결과물을 설명하는 **바디** 가 있다
  - 순수한 형태의 바디는 심볼 리스트에 불과하다
- 심볼은 두 가지 맛(flavor)이 있다
  - 터미널(terminal)
    - 문법의 알파벳에 있는 글자다.
    - 리터럴 값이라고 볼 수 있다.
    - 우리가 정의하는 구문 문법에서 터미널은 스캐너가 내보낸 개별 렉심, 즉 토큰이다.
  - 넌터미널
    - 다른 문법 규칙을 가리키는 기명 참조(named reference)이다
    - 이 규칙을 플레이해서 이 규칙이 생성하는 모든 것을 여기에 삽입하라는 뜻이다
***** 5.1.2 표기법 개선
***** 5.1.3 록스 표현식 문법
**** 5.2 구문 트리 구현
***** 5.2.1 무지향성 객체
***** 5.2.2 트리 메타프로그래밍
**** 5.3 트리 다루기
***** 5.3.1 표현식 문제
***** 5.3.2 비지터 패턴
***** 5.3.3 표현식에 비지터를 적용
**** 5.4 (적당히) 예쁜 출력기
**** 연습 문제
*** 6장 표현식 파싱
**** 6.1 모호함과 파싱 게임
- 우선순위(precedence): *서로 다른 연산자가 섞인 표현식* 에서 어떤 연산자를 먼저 평가할지 정하는 규칙
- 결합법칙(associativity): *동일한 연산자가 죽 이어진 경우* 어느 것을 먼저 평가할지 정하는 규칙
**** 6.2 재귀 하향 파싱
- 재귀 하향(recursive descent)
  - 맨 위(top) 또는 가장 바깥쪽(outmost) 문법 규칙부터 시작해 구문트리리프에 닿을 때까지 점점 중첩된 서브식 속으로 아래로 내려가며 파싱하는 방법이다
  - 재귀 하향 파서는 문법 규칙을 명령형 코드로 직역한 것이다
    - 터미널: 토큰을 매치하여 소비하는 코드
    - 넌터미널: 해당 규칙의 함수를 호출
    - | : if 또는 switch 문
    - * 또는 +: while 또는 for 루프
    - ?: if문
***** 6.2.1 파서 클래스
**** 6.3 구문 에러
***** 6.3.1 패닉 모드 에러 복구
- 파서가 에러를 발견하면 즉시 패닉 모드로 진입한다
- 다시 파싱으로 복귀하기 전, 파서는 그다음 토큰이 파싱 규칙에 매치되도록 자신의 상태와 그다음 토큰을 정렬해야한다
  - 이 과정을 동기화(synchronization)이라고 한다
- 이를 위해 문법에서 동기화 지점을 표시하는 규칙을 선택한다
  - 파서는 이 규칙으로 돌아올 때까지 모든 중첩된 프로덕션에서 점프하여 자신의 파싱 상태를 수정한다.
  - 그런 다음 규칙의 바로 그 지점에 올 수 있는 토큰에 닿을 때까지 토큰을 버림으로써 토큰 스트림을 동기화한다
- 전통적으로 문법에서 동기화하는 지점은 문장 사이다
***** 6.3.2 패닉 모드 진입
***** 6.3.3 재귀 하향 파서 동기화
**** 6.4 파서 연결
**** 연습 문제
**** 디자인 노트 | 로직 vs 역사
*** 7장 표현식 평가
- 언어 구현체가 컴퓨터에게 사용자의 소스 코드를 실행하도록 지시하는 방법은 무궁무진하다. 소스 코드를 기계어로 컴파일할 수도 있고, 다른 하이레벨 언어로 번역할 수도 있다. 아니면 가상 머신 실행에 필요한 바이트코드 형태로 축약시킬 수도 있다
**** 7.1 값을 표현하기
**** 7.2 표현식 평가
***** 7.2.1 리터럴 평가
- 리터럴은 파서의 세상에서 비롯됐지만, 값은 런타임 세계의 일부인 인터프리터 개념이다.
- 그러므로 파서에서 리터럴 토큰을 리터럴 구문 트리로 변환한 것처럼 이제 리터럴 트리 노드를 런타임 값으로 변환할 것이다
***** 7.2.2 괄호 평가
***** 7.2.3 단항식 평가
- 록스 인터프리터는 각 노드가 자신이 할 일을 하기 전에 자기 자식 노드부터 평가하는 **후위 순회** 를 한다
***** 7.2.4 참과 거짓
***** 7.2.5 이항 연산자 평가
**** 7.3 런타임 에러
- 런타임 에러는 프로그램 실행 도중, 언어 시맨틱의 요건이 충족되지 않아 발견된 실패를 리포트한 것이다
***** 7.3.1 런타임 에러 감지
**** 7.4 인터프리터 연결
***** 7.4.1 런타임 에러 리포팅
***** 7.4.2 인터프리터 실행
**** 연습 문제
**** 디자인 노트 | 정적 타이핑과 동적 타이핑
*** 8장 문장과 상태
- 바인딩을 지원하려면 인터프리터에 내부 상태가 필요하다.
  - 처음 프로그램이 시작될 때 변수를 정의하고 사용하는 내내, 인터프리터는 어딘가에는 이 변숫값을 보관해야 한다
- 문장과 상태는 서로 맞물려 있다
  - 문장은 본질적으로 값으로 평가되지 않기 때문에 뭔가 다른 일을 해야 쓸모가 있다
**** 8.1 문장
***** 8.1.1 문장 구문 트리
***** 8.1.2 문장 파싱
***** 8.1.3 문장 실행
**** 8.2 글로벌 변수
- 1. 변수선언문(variable declaration statement): 새로운 변수를 낳는 문장
- 2. 변수식(variable expression) 으로 바인딩에 액세스한다
***** 8.2.1 변수 구문
***** 8.2.2 변수 파싱
**** 8.3 환경
- 변수와 그 값을 연결하는 바인딩은 메모리 어딘가에 저장해야 한다
  - 이 자료 구조를 환경이라고 불러왔다
***** 8.3.1 글로벌 변수의 인터프리팅
**** 8.4 할당
***** 8.4.1 할당 구문
***** 8.4.2 할당 시맨틱
**** 8.5 스코프
- 스코프는 특정 엔티티에 이름을 매핑한 영역이다.
  - 다중 스코프를 사용하면 같은 이름이라도 서로 다른 컨텍스트에서 서로 다른 대상을 참조할 수 있다
- 렉시컬 스코프(lexical scope/static scope)는 프로그램의 텍스트 자체로 스코프의 시작/종료 지점을 나타내는 스코핑 스타일이다
  - 다시말해, 어떤 변수를 사용하는 표현식이 나오면 그 코드를 정적으로 읽기만 해도 어떤 변수 선언을 참조하는지 알 수 있다
***** 8.5.1 중첩과 섀도잉
***** 8.5.2 블록 구문과 시맨틱
- 블록은 (빈 블록까지 포함해) {}로 감싼 일련의 문장 또는 선언이다. 블록은 그 자체로 문장이며, 문장이 허용된 곳이라면 어디든 나타날 수 있다
**** 연습 문제
**** 디자인 노트 | 암묵적 변수 선언
*** 9장 제어 흐름
**** 9.1 튜링 기계(개요)
**** 9.2 조건부 실행
- 제어 흐름은 크게 두 종류로 나뉜다.
  - *조건부(conditional)* 또는 *분기제어흐름(branching control flow)* 는 어떤 코드 조각을 실행하지 않는데 사용된다. 특정 코드 영역을 점프해서 그냥 넘어가라고 하는 것이다
  - *제어흐름루프(control flow loop)* 는 어떤 코드 조각을 두 번 이상 실행한다.
**** 9.3 논리 연산자
**** 9.4 while 루프
**** 9.5 for 루프
***** 9.5.1 디슈가링
**** 연습 문제
**** 디자인 노트 | 구문 슈가 범벅
*** 10장 함수
**** 10.1 함수 호출
- 호출되는 함수의 이름은 실제 호출 구문의 일부가 아니다
  - 호출 대상, 즉 *피호출자(callee)* 는 함수로 평가되는 어떤 표현식이라도 가능하다
- 함수 호출을 나타내는 것은 표현식 뒤에 붙은 괄호다
  - 호출은 `(`로 시작하는 일종의 후외 연산자와 비슷하다고 생각할 수 있다
***** 10.1.1 최대 인수 개수
***** 10.1.2 함수 호출 인터프리팅
***** 10.1.3 호출 타입 에러
***** 10.1.4 애리티 체크
- 애리티(arity)는 함수나 연산에 필요한 인수의 개수를 뜻하는 용어다
  - 예로들면 단항 연산자는 애리티가 1, 이항 연산자는 애리티가 2다
  - 함수의 애리티는 함수에 선언된 매개변수의 개수로 결정된다
**** 10.2 네이티브 함수
- 네이티브 함수는 인터프리터가 구현할 언어가 아닌 호스트 언어로 구현되는 함수를 말한다
- 네이티브 함수는 사용자 프로그램이 실행되는 도중에 호출할 수 있으므로 구현체 런타임의 일부분을 구성한다
***** 10.2.1 시간 측정
- 벤치마크는 인터프리터의 특정 부분을 실행하는 데 걸린 시간을 측정하는 프로그램이다
**** 10.3 함수 선언
**** 10.4 함수 객체
***** 10.4.1 함수 선언 인터프리팅
**** 10.5 리턴문
***** 10.5.1 호출에서 리턴
**** 10.6 로컬 함수와 클로저
- 함수가 선언된 지점의 주변 변수를 '클로즈 오버'하여 유지한다. 이 자료구조를 클로저라고 한다.
**** 연습 문제
*** 11장 리졸빙과 바인딩
**** 11.1 정적 스코프
***** 11.1.1 스코프와 가변 환경
- 스코핑 규칙은 정적 시맨틱의 일부이므로 정적 스코프라고도 한다
- 변수 사용(variable usage)는 변수가 사용된 곳의 표현식을 둘러싼, 가장 안쪽 스코프에서 같은 이름을 가진 앞의 선언을 참조한다.
  - '변수 사용'이라는 말은 변수식과 할당을 모두 커버하는 말이다
  - '앞에 있는'이라는 말은 프로그램 텍스트상으로 앞에 나온다는 말이다
- 구현체에서 환경은 전체 블록이 하나의 스코프, 시간에 따라 변하는 스코프처럼 작동된다
  - 클로저는 다르다. 함수가 선언되면 현재 환경을 가리키는 참조를 **캡처** 해야한다
***** 11.1.2 영속적 환경
**** 11.2 시맨틱 분석
- 시맨틱 분석 프로세스 일례
  - 사용자 프로그램에 등장한 모든 변수를 찾아내 각각 어느 선언을 참조하는지 파악하는 검사 코드
- 파서가 어떤 프로그램이 문법상 올바른지 알려주는(구문 분석) 장치라면
- 시맨틱 분석은 프로그램의 어떤 부분이 실제로 무엇을 의미하는지 알아내는 것이다
  - 이 과정에서 변수 바인딩을 리졸브하기 때문에 표현식이 변수라는 것뿐만 아니라 어떤 변수인지도 알 수 있다
***** 11.2.1 변수 레졸루션 패스
- 파서가 구문 트리를 만든 후, 아직 인터프리터가 트리를 받아 실행하기 전에, 트리에 포함된 모든 변수를 리졸브하기 위해 트리를 한 번 살펴볼 것이다
**** 11.3 리졸버 클래스
***** 11.3.1 블록 리졸빙
***** 11.3.2 변수 선언 리졸빙
***** 11.3.3 변수식 리졸빙
***** 11.3.4 할당식 리졸빙
***** 11.3.5 함수 선언 리졸빙
***** 11.3.6 기타 구문 트리 노드의 리졸빙
**** 11.4 리졸브된 변수의 인터프리팅
***** 11.4.1 리졸브된 변수 액세스
***** 11.4.2 리졸브된 변수 할당
***** 11.4.3 리졸버 실행
**** 11.5 레졸루션 에러
***** 11.5.1 잘못된 리턴 에러
**** 연습 문제
*** 12장 클래스
**** 12.1 OOP와 클래스
**** 12.2 클래스 선언
**** 12.3 인스턴스 생성
**** 12.4 인스턴스 프로퍼티
***** 12.4.1 겟 표현식
***** 12.4.2 셋 표현식
**** 12.5 클래스 메서드
**** 12.6 this
***** 12.6.1 잘못된 this 용례
**** 12.7 생성자와 초기자
***** 12.7.1 init() 직접 호출
***** 12.7.2 init()에서 리턴
**** 연습 문제
**** 디자인 노트 | 프로토타입과 파워
*** 13장 상속
**** 13.1 수퍼클래스와 서브클래스
**** 13.2 메서드 상속
**** 13.3 수퍼클래스 메서드 호출
***** 13.3.1 구문
***** 13.3.2 시맨틱
***** 13.3.3 잘못된 super 용례
**** 13.4 마무리
**** 연습 문제
** 3부 | 바이트코드 가상 머신
*** 14장 바이트코드 청크
**** 14.1 바이트코드란?
***** 14.1.1 AST 탐색의 문제점은?
***** 14.1.2 그냥 네이티브 코드로 컴파일하면?
***** 14.1.3 바이트코드란?
**** 14.2 시작하기
**** 14.3 명령어 청크
***** 14.3.1 동적 명령어 배열
**** 14.4 청크 디셈블링
**** 14.5 상수
***** 14.5.1 값 표현
***** 14.5.2 값 배열
***** 14.5.3 상수 명령어
**** 14.6 줄 정보
***** 14.6.1 줄 정보 디셈블링
**** 연습 문제
**** 디자인 노트 | 개발 중인 언어를 테스트
*** 15장 가상 머신
**** 15.1 명령어 실행 머신
***** 15.1.1 명령어 실행
***** 15.1.2 실행 추적
**** 15.2 값 스택 조작기
***** 15.2.1 VM의 스택
***** 15.2.2 스택 트레이스
**** 15.3 산술 계산기
***** 15.3.1 이항 연산자
**** 연습 문제
**** 디자인 노트 | 레지스터 기반의 바이트코드
*** 16장 온 디맨드 스캐닝
**** 16.1 인터프리터 시동 걸기
***** 16.1.1 컴파일 파이프라인 열기
***** 16.1.2 스캐너의 스캐닝
**** 16.2 한 번에 토큰 하나씩
***** 16.2.1 토큰 스캐닝
**** 16.3 록스의 렉시컬 문법
***** 16.3.1 공백 문자
***** 16.3.2 주석
***** 16.3.3 리터럴 토큰
**** 16.4 식별자와 키워드
***** 16.4.1 트라이와 상태 기계
**** 연습 문제
*** 17장 표현식 컴파일
**** 17.1 싱글 패스 컴파일
**** 17.2 토큰 파싱
***** 17.2.1 구문 에러 처리
**** 17.3 바이트코드 내보내기
**** 17.4 전위식 파싱
***** 17.4.1 토큰 파서
***** 17.4.2 괄호로 그룹핑
***** 17.4.3 단항 음수화
**** 17.5 중위식 파싱
**** 17.6 프랫 파서
***** 17.6.1 우선순위에 따라 파싱
**** 17.7 청크 덤프
**** 연습 문제
**** 디자인 노트 | 파싱은 파싱일 뿐
*** 18장 값 타입
**** 18.1 태그 있는 공용체
**** 18.2 록스의 값과 C의 값
**** 18.3 동적 타입 숫자
***** 18.3.1 단항 부정과 런타임 에러
***** 18.3.2 이항 산술 연산자
**** 18.4 두 가지 새로운 타입
***** 18.4.1 논리 not과 거짓
***** 18.4.2 동등/비교 연산자
**** 연습 문제
*** 19장 문자열
**** 19.1 값과 객체
**** 19.2 구조체 상속
**** 19.3 문자열
**** 19.4 문자열 연산
***** 19.4.1 문자열 연결
**** 19.5 객체 해제
**** 연습 문제
**** 디자인 노트 | 문자열 인코딩
*** 20장 해시 테이블
**** 20.1 버킷 배열
***** 20.1.1 로드 팩터 및 래핑된 키
**** 20.2 충돌 해결
***** 20.2.1 개별 체이닝
***** 20.2.2 오픈 어드레싱
**** 20.3 해시 함수
**** 20.4 해시 테이블
***** 20.4.1 문자열 해싱
***** 20.4.2 엔트리 삽입
***** 20.4.3 할당 및 크기 조정
***** 20.4.4 값 조회
***** 20.4.5 엔트리 삭제
***** 20.4.6 툼스톤 개수 세기
**** 20.5 문자열 인터닝
**** 연습 문제
*** 21장 글로벌 변수
**** 21.1 문장
***** 21.1.1 print 문
***** 21.1.2 표현문
***** 21.1.3 에러 동기화
**** 21.2 변수 선언
**** 21.3 변수 읽기
**** 21.4 할당
**** 연습 문제
*** 22장 로컬 변수
**** 22.1 로컬 변수 표현
**** 22.2 블록문
**** 22.3 로컬 변수 선언
**** 22.4 로컬 변수 사용
***** 22.4.1 로컬 변수 해석
***** 22.4.2 다른 스코프 엣지 케이스
**** 연습 문제
*** 23장 진격과 후퇴
**** 23.1 if 문
***** 23.1.1 else 절
**** 23.2 논리 연산자
***** 23.2.1 논리 or 연산자
**** 23.3 while 문
**** 23.4 for 문
***** 23.4.1 초기자 절
***** 23.4.2 조건절
***** 23.4.3 증분절
**** 연습 문제
**** 디자인 노트 | goto가 그렇게 해로울까?
*** 24장 호출과 함수
**** 24.1 함수 객체
**** 24.2 함수 객체로 컴파일
***** 24.2.1 컴파일 타임에 함수 생성
**** 24.3 호출 프레임
***** 24.3.1 로컬 변수 할당
***** 24.3.2 리턴 주소
***** 24.3.3 호출 스택
**** 24.4 함수 선언
***** 24.4.1 컴파일러 스택
***** 24.4.2 함수 매개변수
**** 24.5 함수 호출
***** 24.5.1 인수를 매개변수에 바인딩
***** 24.5.2 런타임 에러 체크
***** 24.5.3 스택 트레이스 출력
***** 24.5.4 함수에서 리턴
**** 24.6 리턴문
**** 24.7 네이티브 함수
**** 연습 문제
*** 25장 클로저
**** 25.1 클로저 객체
***** 25.1.1 클로저 객체로 컴파일
***** 25.1.2 함수 선언 해석
**** 25.2 업밸류
***** 25.2.1 업밸류 컴파일
***** 25.2.2 업밸류 플랫화
**** 25.3 업밸류 객체
***** 25.3.1 클로저에서의 업밸류
**** 25.4 클로즈드 업밸류
***** 25.4.1 값과 변수
***** 25.4.2 업밸류 클로징
***** 25.4.3 오픈 업밸류 추적
***** 25.4.4 런타임에 업밸류 클로징
**** 연습 문제
**** 디자인 노트 | 루프 변수 클로징
*** 26장 가비지 수집
**** 26.1 도달성
**** 26.2 마크-스윕 가비지 수집
***** 26.2.1 가비지 수집
***** 26.2.2 디버그 로깅
**** 26.3 루트 마킹
***** 26.3.1 불분명한 루트
**** 26.4 객체 참조 추적
***** 26.4.1 색 추상화
***** 26.4.2 회색 객체 워크리스트
***** 26.4.3 회색 객체 처리
**** 26.5 미사용 객체 스위핑
***** 26.5.1 약한 참조와 문자열 풀
**** 26.6 수집은 언제 하나?
***** 26.6.1 레이턴시와 스루풋
***** 26.6.2 자동 조정 힙
**** 26.7 가비지 수집 버그
***** 26.7.1 상수 테이블에 추가
***** 26.7.2 문자열 인터닝
***** 26.7.3 문자열 연결
**** 연습 문제
**** 디자인 노트 | 세대별 수집기
*** 27장 클래스와 인스턴스
**** 27.1 클래스 객체
**** 27.2 클래스 선언
**** 27.3 클래스 인스턴스
**** 27.4 겟/셋 표현식
***** 27.4.1 게터/세터 표현식 해석
**** 연습 문제
*** 28장 메서드와 초기자
**** 28.1 메서드 선언
***** 28.1.1 메서드 표현
***** 28.1.2 메서드 선언 컴파일
***** 28.1.3 메서드 선언 실행
**** 28.2 메서드 참조
***** 28.2.1 바운드 메서드
***** 28.2.2 메서드 액세스
***** 28.2.3 메서드 호출
**** 28.3 this
***** 28.3.1 this 오용 사례
**** 28.4 인스턴스 초기자
***** 28.4.1 초기자 호출
***** 28.4.2 초기자 리턴값
***** 28.4.3 잘못된 초기자 리턴
**** 28.5 호출 최적화
***** 28.5.1 필드 호출
**** 연습 문제
**** 디자인 노트 | 참신성 예산
*** 29장 메서드와 초기자
**** 29.1 메서드 상속
***** 29.1.1 상속 실행
***** 29.1.2 이상한 수퍼클래스
**** 29.2 수퍼클래스 저장
***** 29.2.1 수퍼클래스의 로컬 변수
**** 29.3 수퍼 호출
***** 29.3.1 수퍼 액세스 실행
***** 29.3.2 수퍼 호출을 더 빠르게
**** 29.4 완전한 가상 머신
**** 연습 문제
*** 30장 최적화
**** 30.1 성능 측정
***** 30.1.1 벤치마크
***** 30.1.2 프로파일링
**** 30.2 해시 테이블 프로빙을 더 빠르게
***** 30.2.1 느린 키 래핑
**** 30.3 NaN 박싱
***** 30.3.1 숫자는 무엇이고, 숫자가 아닌 것은 무엇인가?
***** 30.3.2 조건부 지원
***** 30.3.3 숫자
***** 30.3.4 nil과 true/false
***** 30.3.5 객체
***** 30.3.6 Value 함수
***** 30.3.7 성능 평가
**** 30.4 다음 도착지는?
**** 연습 문제
** 4부 | 부록
*** A1장 록스의 전체 문법
**** A1.1 구문 문법
***** A1.1.1 선언
***** A1.1.2 문장
***** A1.1.3 표현식
***** A1.1.4 유틸리티 규칙
**** A1.2 렉시컬 문법
*** A2장 제이록스의 AST 생성기로 만든 자바 클래스 목록
**** A2.1 표현식
***** A2.1.1 할
